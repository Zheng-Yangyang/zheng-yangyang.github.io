<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图论算法0.1版本</title>
    <link href="/2022/08/09/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%950-1%E7%89%88%E6%9C%AC/"/>
    <url>/2022/08/09/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%950-1%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>图论算法更新版本0.1，暂时更新了全部的算法代码实现，以及前面一般的部分算法简单解析。等下次会更新后面一半部分的内容</p><h5 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h5><p>树是一种特殊的图，与图的存储方式相同。</p><p>对于无向图中的边 $ab$，存储两条有向边 $a-&gt;b, b-&gt;a$。</p><p>因此我们可以只考虑有向图的存储。</p><p>(1) 邻接矩阵：g[a][b] 存储边a-&gt;b   一般很少用，用也局限于稠密图</p><p>(2) 邻接表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br></code></pre></td></tr></table></figure><h5 id="图论算法中一些需要记住的知识"><a href="#图论算法中一些需要记住的知识" class="headerlink" title="图论算法中一些需要记住的知识"></a>图论算法中一些需要记住的知识</h5><ol><li>加边函数需要记住，需要知道h[N], e[N], ne[N] 三个数组的含义分别为头节点数组，当前这个点的编号数组，以及下一个点的地址数组，一般的加边函数没有加上数值，这里出现的都是节点编号，如果把值加进去，需要再开一个数组。</li><li>无向图需要用两次加边函数，有向图只需要一个</li><li>需要注意h数组的memset，不然会导致 Time Limit Exceeded  。</li><li></li></ol><h5 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs latex">846. 树的重心<br>给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。<br><br>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。<br><br>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。<br><br>输入格式<br>第一行包含整数 n，表示树的结点数。<br><br>接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。<br><br>输出格式<br>输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。<br><br>数据范围<br>1≤n≤105<br>输入样例<br>9<br>1 2<br>1 7<br>1 4<br>2 8<br>2 5<br>4 3<br>3 9<br>4 6<br>输出样例：<br>4<br></code></pre></td></tr></table></figure><p>思路：</p><p>深度优先遍历就是遵循框架来写，注意的是在图或者树中的深度优先遍历大部分都是内部遍历，即不需要恢复原状的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">//数据范围是10的5次方</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2</span> * N; <span class="hljs-comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span><br><br><span class="hljs-type">int</span> h[N]; <span class="hljs-comment">//邻接表存储树，有n个节点，所以需要n个队列头节点</span><br><span class="hljs-type">int</span> e[M]; <span class="hljs-comment">//存储元素</span><br><span class="hljs-type">int</span> ne[M]; <span class="hljs-comment">//存储列表的next值</span><br><span class="hljs-type">int</span> idx; <span class="hljs-comment">//单链表指针</span><br><span class="hljs-type">int</span> n; <span class="hljs-comment">//题目所给的输入，n个节点</span><br><span class="hljs-type">int</span> ans = N; <span class="hljs-comment">//表示重心的所有的子树中，最大的子树的结点数目</span><br><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">//记录节点是否被访问过，访问过则标记为true</span><br><br><span class="hljs-comment">//a所对应的单链表中插入b  a作为根 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// dfs 框架</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">void dfs(int u)&#123;</span><br><span class="hljs-comment">    st[u]=true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程</span><br><span class="hljs-comment">    for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="hljs-comment">        int j=e[i];</span><br><span class="hljs-comment">        if(!st[j]) &#123;</span><br><span class="hljs-comment">            dfs(j);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//返回以u为根的子树中节点的个数，包括u节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储 删掉某个节点之后，最大的连通子图节点数</span><br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//标记访问过u节点</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">//存储 以u为根的树 的节点数, 包括u，如图中的4号节点</span><br><br>    <span class="hljs-comment">//访问u的每个子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-comment">//因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过</span><br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-built_in">dfs</span>(j);  <span class="hljs-comment">// u节点的单棵子树节点数 如图中的size值</span><br>            res = <span class="hljs-built_in">max</span>(res, s); <span class="hljs-comment">// 记录最大联通子图的节点数</span><br>            sum += s; <span class="hljs-comment">//以j为根的树 的节点数</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//n-sum 如图中的n-size值，不包括根节点4；</span><br>    res = <span class="hljs-built_in">max</span>(res, n - sum); <span class="hljs-comment">// 选择u节点为重心，最大的 连通子图节点数</span><br>    ans = <span class="hljs-built_in">min</span>(res, ans); <span class="hljs-comment">//遍历过的假设重心中，最小的最大联通子图的 节点数</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">//初始化h数组 -1表示尾节点</span><br>    cin &gt;&gt; n; <span class="hljs-comment">//表示树的结点数</span><br><br>    <span class="hljs-comment">// 题目接下来会输入，n-1行数据，</span><br>    <span class="hljs-comment">// 树中是不存在环的，对于有n个节点的树，必定是n-1条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a); <span class="hljs-comment">//无向图</span><br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//可以任意选定一个节点开始 u&lt;=n</span><br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="树与图的广度优先遍历"><a href="#树与图的广度优先遍历" class="headerlink" title="树与图的广度优先遍历"></a>树与图的广度优先遍历</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex">847. 图中点的层次<br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。<br><br>所有边的长度都是 1，点的编号为 1∼n。<br><br>请你求出 1 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 1 的边。<br><br>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。<br><br>数据范围<br>1≤n,m≤105<br>输入样例：<br>4 5<br>1 2<br>2 3<br>3 4<br>1 3<br>1 4<br>输出样例：<br>1<br></code></pre></td></tr></table></figure><p>思路：</p><p>广度优先遍历和搜索之中的广度优先遍历一样，需要先定义队列，然后就是让队列不空，再来判断条件以及入队其他元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> d[N];<span class="hljs-comment">//d[N] 为距离数组，表示各个点到第一个点的距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<span class="hljs-comment">//首先将d数组初始化为-1</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//第一个点的距离为0，接着用这个点去更新其他点</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//表示这个点未被使用</span><br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="图论基本算法概括"><a href="#图论基本算法概括" class="headerlink" title="图论基本算法概括"></a>图论基本算法概括</h5><img src="/2022/08/09/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%950-1%E7%89%88%E6%9C%AC/QQ%E5%9B%BE%E7%89%8720220809150818.png" class><h5 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs latex">849. Dijkstra求最短路 I<br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br><br>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。<br><br>输入格式<br>第一行包含整数 n 和 m。<br><br>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。<br><br>如果路径不存在，则输出 −1。<br><br>数据范围<br>1≤n≤500,<br>1≤m≤105,<br>图中涉及边长均不超过10000。<br><br>输入样例：<br>3 3<br>1 2 2<br>2 3 1<br>1 3 4<br>输出样例：<br>3<br></code></pre></td></tr></table></figure><p>思路：</p><p>迪杰斯特拉算法的思路是，首先将距离数组初始化为无穷大，再将一号点入队，即本身，距离设为0，再循环n - 1 次，寻找还未确定最短路之中的点中距离最短的点。然后再用找到的点更新其他点的距离，如果距离变成了正无穷，就不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//稠密图用领接矩阵来存储</span><br><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//用于存储每个点到起点的最短距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">//用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<span class="hljs-comment">//将t设置为-1 因为Dijkstra算法适用于不存在负权边的图</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)&#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<span class="hljs-comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span><br>                t = j;<span class="hljs-comment">//</span><br>        &#125;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>            st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<span class="hljs-comment">//先全部初始化为无穷</span><br>    <span class="hljs-keyword">while</span> (m -- )&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<span class="hljs-comment">//出现自环取一个最小值</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dijkstra</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="堆优化版dijkstra算法"><a href="#堆优化版dijkstra算法" class="headerlink" title="堆优化版dijkstra算法"></a>堆优化版dijkstra算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs latex">850. Dijkstra求最短路 II<br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。<br><br>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。<br><br>输入格式<br>第一行包含整数 n 和 m。<br><br>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。<br><br>如果路径不存在，则输出 −1。<br><br>数据范围<br>1≤n,m≤1.5×105,<br>图中涉及边长均不小于 0，且不超过 10000。<br>数据保证：如果最短路存在，则最短路的长度不超过 109。<br><br>输入样例：<br>3 3<br>1 2 2<br>2 3 1<br>1 3 4<br>输出样例：<br>3<br></code></pre></td></tr></table></figure><p>思路：</p><p>堆优化版的迪杰斯特拉算法的思路是一样的，但通过定义堆来去除冗余元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>; <span class="hljs-comment">// 把N改为150010就能ac</span><br><br><span class="hljs-comment">// 稀疏图用邻接表来存</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> w[N]; <span class="hljs-comment">// 用来存权重</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 如果为true说明这个点的最短路径已经确定</span><br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span><br>    <span class="hljs-comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），</span><br>    <span class="hljs-comment">// 并标记st为true，所以下一次弹出3+x会continue不会向下执行。</span><br>    w[idx] = c;<br>    e[idx] = y;<br>    ne[idx] = h[x]; <br>    h[x] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="hljs-comment">// 定义一个小根堆</span><br>    <span class="hljs-comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，</span><br>    <span class="hljs-comment">// 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span><br>    heap.<span class="hljs-built_in">push</span>(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        PII k = heap.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 取不在集合S中距离最短的点</span><br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ver = k.second, distance = k.first;<br><br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">// i只是个下标，e中在存的是i这个下标对应的点。</span><br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123; dist[j], j &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        <span class="hljs-built_in">add</span>(x, y, c);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman_ford算法"></a>bellman_ford算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs latex">853. 有边数限制的最短路<br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br><br>请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。<br><br>注意：图中可能 存在负权回路 。<br><br>输入格式<br>第一行包含三个整数 n,m,k。<br><br>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。<br><br>点的编号为 1∼n。<br><br>输出格式<br>输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。<br><br>如果不存在满足条件的路径，则输出 impossible。<br><br>数据范围<br>1≤n,k≤500,<br>1≤m≤10000,<br>1≤x,y≤n，<br>任意边长的绝对值不超过 10000。<br><br>输入样例：<br>3 3 1<br>1 2 1<br>2 3 1<br>1 3 3<br>输出样例：<br>3<br></code></pre></td></tr></table></figure><p>思路：</p><p>迪杰斯特拉算法无法解决负权边的问题，故出现了bellman_ford算法 </p><img src="/2022/08/09/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%950-1%E7%89%88%E6%9C%AC/652_fa97a4d6a4-1.png" class title="1.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>,M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <br>&#125;edges[M];<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> last[N];<span class="hljs-comment">//备份数组，防止出现连锁效应</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(last, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> e = edges[j];<br>            dist[e.b] = <span class="hljs-built_in">min</span>(dist[e.b], last[e.a] + e.c);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        edges[i] = &#123;a, b, c&#125;;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <br>    <span class="hljs-keyword">if</span>(dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>)    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<span class="hljs-comment">//这里只能写这个</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; dist[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs latex">851. spfa求最短路<br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br><br>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。<br><br>数据保证不存在负权回路。<br><br>输入格式<br>第一行包含整数 n 和 m。<br><br>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。<br><br>如果路径不存在，则输出 impossible。<br><br>数据范围<br>1≤n,m≤105,<br>图中涉及边长绝对值均不超过 10000。<br><br>输入样例：<br>3 3<br>1 2 5<br>2 3 -3<br>1 3 4<br>输出样例：<br>2<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">spfa</span>();<br><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex">854. Floyd求最短路<br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。<br><br>再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 impossible。<br><br>数据保证图中不存在负权回路。<br><br>输入格式<br>第一行包含三个整数 n,m,k。<br><br>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。<br><br>接下来 k 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。<br><br>输出格式<br>共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。<br><br>数据范围<br>1≤n≤200,<br>1≤k≤n2<br>1≤m≤20000,<br>图中涉及边长绝对值均不超过 10000。<br><br>输入样例：<br>3 3 2<br>1 2 1<br>2 3 2<br>1 3 1<br>2 1<br>1 3<br>输出样例：<br>impossible<br>1<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m, Q;<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], c);<br>    &#125;<br><br>    <span class="hljs-built_in">floyd</span>();<br><br>    <span class="hljs-keyword">while</span> (Q -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br><br>        <span class="hljs-type">int</span> t = d[a][b];<br>        <span class="hljs-keyword">if</span> (t &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs latex">858. Prim算法求最小生成树<span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。<br><br>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。<br><br>给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。<br><br>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。<br><br>输出格式<br>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。<br><br>数据范围<br>1≤n≤500,<br>1≤m≤105,<br>图中涉及边的边权的绝对值均不超过 10000。<br><br>输入样例：<br>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4<br>输出样例：<br>6<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">prim</span>();<br><br>    <span class="hljs-keyword">if</span> (t == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs latex">859. Kruskal算法求最小生成树<br>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。<br><br>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。<br><br>给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。<br><br>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。<br><br>输出格式<br>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。<br><br>数据范围<br>1≤n≤105,<br>1≤m≤2∗105,<br>图中涉及边的边权的绝对值均不超过 1000。<br><br>输入样例：<br>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4<br>输出样例：<br>6<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)<br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        edges[i] = &#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">kruskal</span>();<br><br>    <span class="hljs-keyword">if</span> (t == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs latex">860. 染色法判定二分图<br>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。<br><br>请你判断这个图是否是二分图。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。<br><br>输出格式<br>如果给定图是二分图，则输出 Yes，否则输出 No。<br><br>数据范围<br>1≤n,m≤105<br>输入样例：<br>4 4<br>1 3<br>1 4<br>2 3<br>2 4<br>输出样例：<br>Yes<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> color[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!color[j])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!color[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs latex">861. 二分图的最大匹配<br>给定一个二分图，其中左半部包含 n1 个点（编号 1∼n1），右半部包含 n2 个点（编号 1∼n2），二分图共包含 m 条边。<br><br>数据保证任意一条边的两个端点都不可能在同一部分中。<br><br>请你求出二分图的最大匹配数。<br><br>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 &#123;E&#125; 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。<br><br>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。<br><br>输入格式<br>第一行包含三个整数 n1、 n2 和 m。<br><br>接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。<br><br>输出格式<br>输出一个整数，表示二分图的最大匹配数。<br><br>数据范围<br>1≤n1,n2≤500,<br>1≤u≤n1,<br>1≤v≤n2,<br>1≤m≤105<br>输入样例：<br>2 2 4<br>1 1<br>1 2<br>2 1<br>2 2<br>输出样例：<br>2<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n1, n2, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> match[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++ ;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周赛01</title>
    <link href="/2022/08/07/%E5%91%A8%E8%B5%9B01/"/>
    <url>/2022/08/07/%E5%91%A8%E8%B5%9B01/</url>
    
    <content type="html"><![CDATA[<h4 id="AcWing周赛"><a href="#AcWing周赛" class="headerlink" title="AcWing周赛"></a>AcWing周赛</h4><h5 id="4503-数对数量"><a href="#4503-数对数量" class="headerlink" title="4503.数对数量"></a>4503.<a href="https://www.acwing.com/problem/content/4506/">数对数量</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex">请计算，共有多少个整数数对 (x,y) 同时满足：<br><br>0≤x≤a<br>0≤y≤b<br>x+y=n<br>例如，当 a=5,b=6,n=3 时，共有 4 个满足条件的数对：(0,3),(1,2),(2,1),(3,0)。<br><br>输入格式<br>第一行包含整数 a。<br><br>第二行包含整数 b。<br><br>第三行包含整数 n。<br><br>输出格式<br>一个整数，表示满足条件的数对数量。<br><br>数据范围<br>前三个测试点满足 1≤a,b≤10，1≤n≤a+b。<br>所有测试点满足 1≤a,b≤300，1≤n≤a+b。<br><br>输入样例1：<br>5<br>6<br>3<br>输出样例1：<br>4<br>输入样例2：<br>5<br>3<br>5<br>输出样例2：<br>4<br></code></pre></td></tr></table></figure><p>思路：直接模拟即可，需要注意的是(0, 3) 和(3, 0)是两个不同的答案，所以不用担心去重，我傻逼了还考虑去重，用了个set＋pair 发现不用去重。两种代码都存一下吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>直接法<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, n;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= a; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= b; j ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i + j == n)  res ++;<br>        &#125;<br>        <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-number">2.</span>set&lt;pair&gt; 法<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, n;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;<br>    set&lt;PII&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= a; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= b; j ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i + j == n)  st.<span class="hljs-built_in">insert</span>(&#123;i, j&#125;);<br>        &#125;<br>        <br>    cout &lt;&lt; st.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure><h5 id="4504-字符串消除"><a href="#4504-字符串消除" class="headerlink" title="4504.字符串消除"></a>4504.<a href="https://www.acwing.com/problem/content/4507/">字符串消除</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex">李华和张红正在玩字符串消除游戏。<br><br>游戏规则如下：<br><br>给定一个由小写字母构成的字符串 s。<br>两人轮流进行消除操作，当轮到一人时，其任务是在当前 s 中找到两个连续且相同的字母，并将它们从 s 中消除。例如，当 s 为 abba 时，可以消除 bb，使 s 变为 aa。<br>第一个无法进行消除操作的选手视为失败。<br>已知，游戏由李华执先手，且两人都采取最优策略。<br><br>请问，李华是否可以获胜。<br><br>输入格式<br>一行，一个字符串 s。<br><br>输出格式<br>如果李华可以获胜，则输出 Yes，否则输出 No。<br><br>数据范围<br>前 5 个测试点满足 1≤|s|≤10。<br>所有测试点满足 1≤|s|≤105。<br><br>输入样例1：<br>abacaba<br>输出样例1：<br>No<br>输入样例2：<br>iiq<br>输出样例2：<br>Yes<br>输入样例3：<br>abba<br>输出样例3：<br>No<br></code></pre></td></tr></table></figure><p>思路：刚开始看到这道题很懵，然后想到了有点像的一道题，括号序列<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a> 可以去看看这道题的题解，然后就想到了用栈来解决这个问题。刚开始被那道题的思路带到了，一位还是得判断栈是不是空，后来发现需要求解的是操作的次数是奇数还是偶数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>    stk.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">size</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == s[i])    &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>            cnt ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(s[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4505-最大子集"><a href="#4505-最大子集" class="headerlink" title="4505.最大子集"></a>4505.最大子集</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs latex">给定一个包含 n 个元素的整数集合。<br><br>集合中的元素两两不同。<br><br>请你找到一个该集合的最大子集，要求子集内的元素满足任意两元素之差的绝对值都是 2 的整数幂。<br><br>注意，只包含 1 个元素的子集一定满足条件。<br><br>输入格式<br>第一行包含整数 n。<br><br>第二行包含 n 个两两不同的整数 x1,x2,…,xn。<br><br>输出格式<br>第一行输出一个整数 m，表示满足条件的最大子集包含的元素数量。<br><br>第二行包含 m 个整数，表示最大子集中包含的元素。<br><br>如果方案不唯一，则输出任意合理方案均可。<br><br>数据范围<br>前 6 个测试点满足 1≤n≤10。<br>所有测试点满足 1≤n≤2×105，−109≤xi≤109。<br><br>注意：本题数据范围较大，慎用cin/cout、unordered<span class="hljs-built_in">_</span>set、unordered<span class="hljs-built_in">_</span>map等操作。<br><br>输入样例1：<br>6<br>3 5 4 7 10 12<br>输出样例1：<br>3<br>7 3 5<br>输入样例2：<br>5<br>-1 2 5 8 11<br>输出样例2：<br>1<br>8<br></code></pre></td></tr></table></figure><p>思路：</p><p>昨天第二次a了两题，然后第三题就没有心思考虑了，后面发现第三题仔细思考还是有很多可取之处的。</p><p>下面来看看y总是如何分析的。从下面的截图可以看出，要使等式成立，y必须等于x，z也必须等于y，所以这三个就是等差数列，这是三个数的情况，如果是4个数的话，最大的数减去最小的数就是$3*2^{x}$,必然不是$2^k$,而且也可以推出，如果超过4个数也会有类似的矛盾.所以可以发现只有三个数，所以可以直接枚举三个来分析。所以最多有三个，最少有一个。又由于这道题卡常数，需要手写哈希表</p><img src="/2022/08/07/%E5%91%A8%E8%B5%9B01/image-20220807134352465.png" class title="image-20220807134352465"><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-params">#</span>include &lt;iostream&gt;<br><span class="hljs-params">#</span>include &lt;cstring&gt;<br><span class="hljs-params">#</span>include &lt;algorithm&gt;<br>using namespace std;<br>const int N = 200010, M = 1999997, INF = 0x3f3f3f3f;//M为哈希表的长度，一般开个五六倍以上<br>int q[N], h[M];<br>int find(int x)&#123;<br>    int t = (x <span class="hljs-comment">% M + M) % M;</span><br>    while (h[t] != INF <span class="hljs-built_in">&amp;</span><span class="hljs-built_in">&amp;</span> h[t] != x)<br>        if ( ++ t == M)<br>            t = 0;<br>    return t;<br>    <br>&#125;<br><br><br>int main()<br>&#123;<br>    int n;<br>    scanf(&quot;<span class="hljs-comment">%d&quot;, &amp;n);</span><br>    for(int i = 0; i &lt; n; i ++) scanf(&quot;<span class="hljs-comment">%d&quot;, &amp;q[i]);</span><br>    sort(q, q + n);<br>    memset(h, 0x3f, sizeof h);//初始化哈希表，用正无穷这个特殊值来表示<br>    int res[3], s[3];<br>    int rt = 0, st = 0; //rt为集合长度，st为集合长度为3的集合长度<br>    for (int i = 0; i &lt; n; i ++ )<br>    &#123;<br>        for (int j = 0; j &lt;= 30; j ++ )<br>        &#123;<br>            int d = 1 &lt;&lt; j;//公差<br>            s[0] = q[i], st = 1;//集合初始有q[i]这个数<br>            for (int k = 1; k &lt;= 2; k ++ )<br>            &#123;<br>                int x = q[i] - d * k;<br>                if (h[find(x)] == INF) break;//表示不存在<br>                s[st ++ ] = x;<br>            &#125;<br>            if (rt &lt; st)<br>            &#123;<br>                rt = st;<br>                memcpy(res, s, sizeof s);<br>                if (rt == 3) break;<br>            &#125;<br>        &#125;<br>        if (rt == 3) break;<br>        h[find(q[i])] = q[i];<br>    &#125;<br>    printf(&quot;<span class="hljs-comment">%d\n&quot;, rt);</span><br>    for (int i = 0; i &lt; rt; i ++ )<br>        printf(&quot;<span class="hljs-comment">%d &quot;, res[i]);</span><br>    return 0;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LeetCode第84场双周赛"><a href="#LeetCode第84场双周赛" class="headerlink" title="LeetCode第84场双周赛"></a>LeetCode第84场双周赛</h4><h5 id="6141-合并相似的物品"><a href="#6141-合并相似的物品" class="headerlink" title="6141. 合并相似的物品"></a>6141. 合并相似的物品</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：<br><br>items[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。<br>items 中每件物品的价值都是 唯一的 。<br>请你返回一个二维数组 ret，其中 ret[i] = [valuei, weighti]， weighti 是所有价值为 valuei 物品的 重量之和 。<br><br>注意：ret 应该按价值 升序 排序后返回。<br><br> <br><br>示例 1：<br><br>输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]<br>输出：[[1,6],[3,9],[4,5]]<br>解释：<br>value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。<br>value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。<br>value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。<br>所以，我们返回 [[1,6],[3,9],[4,5]] 。<br>示例 2：<br><br>输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]<br>输出：[[1,4],[2,4],[3,4]]<br>解释：<br>value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。<br>value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。<br>value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。<br>所以，我们返回 [[1,4],[2,4],[3,4]] 。<br>示例 3：<br><br>输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]<br>输出：[[1,7],[2,4],[7,1]]<br>解释：<br>value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。<br>value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。<br>value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。<br>所以，我们返回 [[1,7],[2,4],[7,1]] 。<br> <br><br>提示：<br><br>1 &lt;= items1.length, items2.length &lt;= 1000<br>items1[i].length == items2[i].length == 2<br>1 &lt;= valuei, weighti &lt;= 1000<br>items1 中每个 valuei 都是 唯一的 。<br>items2 中每个 valuei 都是 唯一的 。<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/merge-similar-items<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：两个思路。第一个思路：用map存对应的关键值和数量，然后，由于map本来就是有序的所以可以直接输出</p><p>​第二个思路：排序+归并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map做法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items2) &#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : items1) hash[item[<span class="hljs-number">0</span>]] += item[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : items2) hash[item[<span class="hljs-number">0</span>]] += item[<span class="hljs-number">1</span>];<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [k, v] : hash)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(&#123;k, v&#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br>排序+归并做法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items2) &#123;<br>        <span class="hljs-built_in">sort</span>(items1.<span class="hljs-built_in">begin</span>(), items1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(items2.<span class="hljs-built_in">begin</span>(), items2.<span class="hljs-built_in">end</span>());<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; items1.<span class="hljs-built_in">size</span>() || j &lt; items2.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (j == items2.<span class="hljs-built_in">size</span>()) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(items1[i]);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == items1.<span class="hljs-built_in">size</span>()) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(items2[j]);<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (items1[i][<span class="hljs-number">0</span>] &lt; items2[j][<span class="hljs-number">0</span>]) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(items1[i]);<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (items1[i][<span class="hljs-number">0</span>] &gt; items2[j][<span class="hljs-number">0</span>]) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(items2[j]);<br>                    j++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;items1[i][<span class="hljs-number">0</span>], items1[i][<span class="hljs-number">1</span>] + items2[j][<span class="hljs-number">1</span>]&#125;);<br>                    i++;<br>                    j++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;    <br></code></pre></td></tr></table></figure><h5 id="6142-统计坏数对的数目"><a href="#6142-统计坏数对的数目" class="headerlink" title="6142. 统计坏数对的数目"></a><a href="https://leetcode.cn/problems/count-number-of-bad-pairs/">6142. 统计坏数对的数目</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你一个下标从 0 开始的整数数组 nums 。如果 i &lt; j 且 j - i != nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。<br><br>请你返回 nums 中 坏数对 的总数目。<br><br> <br><br>示例 1：<br><br>输入：nums = [4,1,3,3]<br>输出：5<br>解释：数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。<br>数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。<br>数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。<br>数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。<br>数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。<br>总共有 5 个坏数对，所以我们返回 5 。<br>示例 2：<br><br>输入：nums = [1,2,3,4,5]<br>输出：0<br>解释：没有坏数对。<br> <br><br>提示：<br><br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 109<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/count-number-of-bad-pairs<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：我们可以发现将上面的条件互换，就可以构造一个新的数组，并且该数组是 nums[i] - i 组成的，然后我们再在该数组中排列组合求得好数对的个数。用总的数对个数减去好数对的个数，就是坏数对的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x * (x - <span class="hljs-number">1LL</span>)/<span class="hljs-number">2</span>;  <span class="hljs-comment">//1LL 可以自动转换成LL类型的数据</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countBadPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        LL res = <span class="hljs-built_in">C</span>(n);<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            hash[nums[i] - i] ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [k, v] : hash)&#123;<br>            res -= <span class="hljs-built_in">C</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="6174-任务调度器-II"><a href="#6174-任务调度器-II" class="headerlink" title="6174. 任务调度器 II"></a><a href="https://leetcode.cn/problems/task-scheduler-ii/">6174. 任务调度器 II</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。<br><br>同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。<br><br>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：<br><br>完成 tasks 中的下一个任务<br>休息一天<br>请你返回完成所有任务所需的 最少 天数。<br><br> <br><br>示例 1：<br><br>输入：tasks = [1,2,1,2,3,1], space = 3<br>输出：9<br>解释：<br>9 天完成所有任务的一种方法是：<br>第 1 天：完成任务 0 。<br>第 2 天：完成任务 1 。<br>第 3 天：休息。<br>第 4 天：休息。<br>第 5 天：完成任务 2 。<br>第 6 天：完成任务 3 。<br>第 7 天：休息。<br>第 8 天：完成任务 4 。<br>第 9 天：完成任务 5 。<br>可以证明无法少于 9 天完成所有任务。<br>示例 2：<br><br>输入：tasks = [5,8,8,5], space = 2<br>输出：6<br>解释：<br>6 天完成所有任务的一种方法是：<br>第 1 天：完成任务 0 。<br>第 2 天：完成任务 1 。<br>第 3 天：休息。<br>第 4 天：休息。<br>第 5 天：完成任务 2 。<br>第 6 天：完成任务 3 。<br>可以证明无法少于 6 天完成所有任务。<br> <br><br>提示：<br><br>1 &lt;= tasks.length &lt;= 105<br>1 &lt;= tasks[i] &lt;= 109<br>1 &lt;= space &lt;= tasks.length<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/task-scheduler-ii<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：可以证明每次任务越早完成越好，而且每次同种类型完成的人物需要比上一次完成同样的人物多space + 1 天，用一个哈希表记录上次任务完成的天数，然后再分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">taskSchedulerII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; tasks, <span class="hljs-type">int</span> space)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = tasks.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, LL&gt; hash;<br>        LL res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : tasks)&#123;<br>            res = <span class="hljs-built_in">max</span>(res + <span class="hljs-number">1</span>, hash[x]);<br>            hash[x] = res + space + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="6144-将数组排序的最少替换次数"><a href="#6144-将数组排序的最少替换次数" class="headerlink" title="6144. 将数组排序的最少替换次数"></a><a href="https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/">6144. 将数组排序的最少替换次数</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你一个下表从 0 开始的整数数组 nums 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。<br><br>比方说，nums = [5,6,7] 。一次操作中，我们可以将 nums[1] 替换成 2 和 4 ，将 nums 转变成 [5,2,4,7] 。<br>请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。<br><br> <br><br>示例 1：<br><br>输入：nums = [3,9,3]<br>输出：2<br>解释：以下是将数组变成非递减顺序的步骤：<br>- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] <br>- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] <br>总共需要 2 步将数组变成非递减有序，所以我们返回 2 。<br>示例 2：<br><br>输入：nums = [1,2,3,4,5]<br>输出：0<br>解释：数组已经是非递减顺序，所以我们返回 0 。<br> <br><br>提示：<br><br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 109<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/minimum-replacements-to-sort-the-array<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">贪心) O(n)<br>注意到，数字只会越拆分越小，所以需要对较大的数字下手。<br>从数组末尾开始往前寻找，找到第一个非递减顺序的位置 p，满足 p&gt;0 且 nums(p)&lt;nums(p−1)。<br>如果 p 不存在，则说明数组已经是非递减顺序，直接返回。<br>定义最大可保留的数字为 target，初始化 target:=nums(p)。从 p−1 开始倒序拆分。<br>如果 nums(i) mod target=0，则说明 nums(i) 可以完全拆分为若干个 target，则答案增加 nums(i)/target−1，并且 target 保持不变。<br>否则，拆分的最少次数就是 c:=nums(i)/target 次，但拆分为 c+1 个数字后需要尽可能的让最小的数字最大（作为下一次拆分的 target），此时最小数字的最大可能值为 target:=nums(i)/(c+1)。<br>注意到，两种情况可以合到一起处理，即直接从数组末尾开始计算。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">LL <span class="hljs-title">minimumReplacement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        LL ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> target = nums[n - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> c = nums[i] / target;<br><br>            <span class="hljs-keyword">if</span> (nums[i] % target == <span class="hljs-number">0</span>) &#123;<br>                ans += c - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += c;<br>                target = nums[i] / (c + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS_0.1</title>
    <link href="/2022/08/05/DFS-0-1/"/>
    <url>/2022/08/05/DFS-0-1/</url>
    
    <content type="html"><![CDATA[<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>分析dfs常见的两种模型，第一个是连通性模型，第二个是搜索顺序模型。在DFS中，一个很容易搞错的事情就是需不需要恢复现场，但是我们这样分析的话，就很容易。我们把dfs分成两种，第一种就是只是求内部的数据，比如从一个点到另一个点，这种题目就不需要恢复现场，另外一种就是外部实现的。比如我们要列举不同的形成方案，这种的题目，我们可以想一想，每次形成新的方案的时候就需要恢复现场。</p><h5 id="DFS性质简述版"><a href="#DFS性质简述版" class="headerlink" title="DFS性质简述版"></a>DFS性质简述版</h5><p>可以仔细区别下面两种模型，我们可以发现第一种模型都不需要恢复状态，第二种都需要恢复，我们把第一种称为内部搜索，第二种称为外部搜索。</p><p>DFS的具体步骤：</p><p>先找到开始的状态，确定需要求的东西是什么，是块数还是个数。然后后面的步骤就和bfs很像了，先去判断掉错误情况，然后再需要去寻找递归状态。有些dfs需要加剪枝去除重复和冗余状态，在这里就没怎么讲解，后面会有一个dfs_0.2讲解带剪枝的版本。</p><h5 id="DFS之连通性模型"><a href="#DFS之连通性模型" class="headerlink" title="DFS之连通性模型"></a>DFS之连通性模型</h5><p>1112.<a href="https://www.acwing.com/problem/content/1114/">迷宫</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs latex">一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由 n∗n 的格点组成，每个格点只有2种状态，.和<span class="hljs-params">#</span>，前者表示可以通行后者表示不能通行。<br><br>同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。<br><br>如果起点或者终点有一个不能通行(为<span class="hljs-params">#</span>)，则看成无法办到。<br><br>注意：A、B不一定是两个不同的点。<br><br>输入格式<br>第1行是测试数据的组数 k，后面跟着 k 组输入。<br><br>每组测试数据的第1行是一个正整数 n，表示迷宫的规模是 n∗n 的。<br><br>接下来是一个 n∗n 的矩阵，矩阵中的元素为.或者<span class="hljs-params">#</span>。<br><br>再接下来一行是 4 个整数 ha,la,hb,lb，描述 A 处在第 ha 行, 第 la 列，B 处在第 hb 行, 第 lb 列。<br><br>注意到 ha,la,hb,lb 全部是从 0 开始计数的。<br><br>输出格式<br>k行，每行输出对应一个输入。<br><br>能办到则输出“YES”，否则输出“NO”。<br><br>数据范围<br>1≤n≤100<br>输入样例：<br>2<br>3<br>.<span class="hljs-params">##</span><br>..<span class="hljs-params">#</span><br><span class="hljs-params">#</span>..<br>0 0 2 2<br>5<br>.....<br><span class="hljs-params">###</span>.<span class="hljs-params">#</span><br>..<span class="hljs-params">#</span>..<br><span class="hljs-params">###</span>..<br>...<span class="hljs-params">#</span>.<br>0 0 4 0<br>输出样例:<br>YES<br>NO<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> xa, xb, ya, yb;<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(x == xb &amp;&amp; y == yb)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    st[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)&#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(a, b))   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;xa, &amp;ya, &amp;xb, &amp;yb);<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<span class="hljs-comment">//每次需要重置状态数组</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(xa, ya)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1113.<a href="https://www.acwing.com/problem/content/1115/">红与黑</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs latex">有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。<br><br>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。<br><br>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。<br><br>输入格式<br>输入包括多个数据集合。<br><br>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。<br><br>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下<br><br>1）‘.’：黑色的瓷砖；<br>2）‘<span class="hljs-params">#</span>’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。<br><br>当在一行中读入的是两个零时，表示输入结束。<br><br>输出格式<br>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。<br><br>数据范围<br>1≤W,H≤20<br>输入样例：<br>6 9 <br>....<span class="hljs-params">#</span>. <br>.....<span class="hljs-params">#</span> <br>...... <br>...... <br>...... <br>...... <br>...... <br><span class="hljs-params">#</span>@...<span class="hljs-params">#</span> <br>.<span class="hljs-params">#</span>..<span class="hljs-params">#</span>. <br>0 0<br>输出样例：<br>45<br></code></pre></td></tr></table></figure><p>这道题用dfs和bfs实现了，可以看看他们之间的区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dfs版本<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    st[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(g[a][b] != <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>        cnt += <span class="hljs-built_in">dfs</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; m &gt;&gt; n , n || m)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)  <br>                    x = i, y = j;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(x, y) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br>bfs版本<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25</span>, M = N * N;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br>PII q[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)<br>    &#123;<br>        PII t = q[hh ++];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[a][b] != <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[a][b])    <span class="hljs-keyword">continue</span>;<br>            q[++ tt] = &#123;a, b&#125;;<br>            st[a][b] = <span class="hljs-literal">true</span>;<br>            cnt ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; m &gt;&gt; n , n || m)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)  <br>                    x = i, y = j;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout &lt;&lt; <span class="hljs-built_in">bfs</span>(x, y) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="DFS之搜索顺序"><a href="#DFS之搜索顺序" class="headerlink" title="DFS之搜索顺序"></a>DFS之搜索顺序</h5><p>1116.<a href="https://www.acwing.com/problem/content/description/1118/">马走日</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs latex">马在中国象棋以日字形规则移动。<br><br>请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。<br><br>输入格式<br>第一行为整数 T，表示测试数据组数。<br><br>每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。<br><br>输出格式<br>每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。<br><br>数据范围<br>1≤T≤9,<br>1≤m,n≤9,<br>1≤n×m≤28,<br>0≤x≤n−1,<br>0≤y≤m−1<br>输入样例：<br>1<br>5 4 0 0<br>输出样例：<br>32<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cnt == n * m)<br>    &#123;<br>        ans ++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    st[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b])    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(a, b, cnt + <span class="hljs-number">1</span>);<br>    &#125;<br>    st[x][y] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y);<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        ans = <span class="hljs-number">0</span>;<span class="hljs-comment">//这个必须加上，因为每一组数据都需要重新清空</span><br>        <span class="hljs-built_in">dfs</span>(x, y, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>1117.<a href="https://www.acwing.com/problem/content/1119/">单词接龙</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">单词接龙是一个与我们经常玩的成语接龙相类似的游戏。<br><br>现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。<br><br>在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。<br><br>我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。<br><br>输入格式<br>输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。<br><br>你可以假定以此字母开头的“龙”一定存在。<br><br>输出格式<br>只需输出以此字母开头的最长的“龙”的长度。<br><br>数据范围<br>n≤20<br>输入样例：<br>5<br>at<br>touch<br>cheat<br>choose<br>tact<br>a<br>输出样例：<br>23<br>提示<br>连成的“龙”为 atoucheatactactouchoose。<br></code></pre></td></tr></table></figure><p>这道题需要多看看几次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><span class="hljs-type">int</span> n;<br>string word[N];<br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">// 编号为i的字符串与编号为j的字符串拼接的长度如i：asd，j：sdf，拼接长度为最小值g[i][j] = 2</span><br><span class="hljs-type">int</span> used[N];<span class="hljs-comment">//编号为i的单词使用次数</span><br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string dragon, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function"></span>&#123;<br>    ans = <span class="hljs-built_in">max</span>((<span class="hljs-type">int</span>)dragon.<span class="hljs-built_in">size</span>(), ans);<br>    used[last] ++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(g[last][i] &amp;&amp; used[i] &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(dragon + word[i].<span class="hljs-built_in">substr</span>(g[last][i]), i);<br>        &#125;<br>        <br>    &#125;<br>    used[last] --;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; word[i];<br>    <span class="hljs-type">char</span> start;<br>    cin &gt;&gt; start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>            string a = word[i], b = word[j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-built_in">min</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>()); k ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">substr</span>(a.<span class="hljs-built_in">size</span>() - k, k) == b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k))&#123;<br>                    g[i][j] = k;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(word[i][<span class="hljs-number">0</span>] == start)<br>                <span class="hljs-built_in">dfs</span>(word[i], i);<br>        &#125;<br>        cout &lt;&lt; ans;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS中floodfill算法总结</title>
    <link href="/2022/08/02/BFS%E4%B8%ADfloodfill%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/02/BFS%E4%B8%ADfloodfill%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="关于bfs中的floodfill算法总结"><a href="#关于bfs中的floodfill算法总结" class="headerlink" title="关于bfs中的floodfill算法总结"></a>关于bfs中的floodfill算法总结</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>floodfill 是宽度优先搜索中一个经典模型，用来判断连通块的数量以及一些其他性质。但其本质还是宽度优先搜索</p><img src="/2022/08/02/BFS%E4%B8%ADfloodfill%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/floodfill.png" class><h4 id="flood算法过程简介"><a href="#flood算法过程简介" class="headerlink" title="flood算法过程简介"></a>flood算法过程简介</h4><p>首先宽度优先搜索都是需要用队列完成，所以一般都是用数组模拟队列去完成，然后由于要保存两个信息，自然就有了定义pair等操作，为了保证是线性的复杂度，所以一个状态数组也是必不可少的。还有一点需要注意的是，注意读入的是字符还是整型。不然答案错了很难debug出来</p><p>接着是具体步骤。前面的操作都是相同的，将该点放入队列，然后标记该点已被使用，接下来就是队列不空的操作，取出队列头操作。接下来需要分两种，一种是统计周围八个元素的，这种情况，我们一般写一个二重循环来判断，接着最重要也是最容易出错的，就是判断哪些情况需要特判掉，比如数组刚好等于要遍历的那个点，数组越界，该点已经被用过(标记过)，还有不同条件的具体要求。判断所有条件之后，然后就需要将这个点加入队尾，然后标记这个点用过。第二种情况是统计周围四个元素的，这种一般定义一个dx和dy数组，分别表示上下左右四个方向，然后再去求后面的操作。</p><h4 id="1-1097-池塘计数"><a href="#1-1097-池塘计数" class="headerlink" title="1.1097. 池塘计数"></a>1.1097. <a href="https://www.acwing.com/problem/content/1099/">池塘计数</a></h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs latex">农夫约翰有一片 N∗M 的矩形土地。<br><br>最近，由于降雨的原因，部分土地被水淹没了。<br><br>现在用一个字符矩阵来表示他的土地。<br><br>每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。<br><br>现在，约翰想知道他的土地中形成了多少片池塘。<br><br>每组相连的积水单元格集合可以看作是一片池塘。<br><br>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。<br><br>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。<br><br>输入格式<br>第一行包含两个整数 N 和 M。<br><br>接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。<br><br>输出格式<br>输出一个整数，表示池塘数目。<br><br>数据范围<br>1≤N,M≤1000<br>输入样例：<br>10 12<br>W........WW.<br>.WWW.....WWW<br>....WW...WW.<br>.........WW.<br>.........W..<br>..W......W..<br>.W.W.....WW.<br>W.W.W.....W.<br>.W.W......W.<br>..W.......W.<br>输出样例：<br>3<br></code></pre></td></tr></table></figure><p>最基础的floodfill算法，只是统计连通块的数量的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = N * N;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII q[M];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        PII t = q[hh ++]; <span class="hljs-comment">// 取出队头</span><br>        <span class="hljs-comment">//遍历周围八个元素可以用一个二重循环来写</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t.x - <span class="hljs-number">1</span>; i &lt;= t.x + <span class="hljs-number">1</span>; i ++)<span class="hljs-comment">//注意是需要有等号的</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t.y - <span class="hljs-number">1</span>; j &lt;= t.y + <span class="hljs-number">1</span>; j ++)&#123;<span class="hljs-comment">//注意那些需要特判掉的情况不要漏掉</span><br>                <span class="hljs-keyword">if</span>(i == t.x &amp;&amp; j == t.y)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= m)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(st[i][j])    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>                q[++ tt] = &#123;i, j&#125;;<br>                st[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);  <span class="hljs-comment">//可以一排直接读一个字符串，不用二重循环 而且读s不需要加取址</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j] == <span class="hljs-string">&#x27;W&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">bfs</span>(i, j);<br>                        cnt ++;<br>                    &#125;<br>            &#125;<br>            <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <br>        <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1098-城堡问题"><a href="#2-1098-城堡问题" class="headerlink" title="2.1098. 城堡问题"></a>2.1098. <a href="https://www.acwing.com/problem/content/1100/">城堡问题</a></h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs latex"> 1   2   3   4   5   6   7  <br>   <span class="hljs-params">#############################</span><br> 1 <span class="hljs-params">#</span>   |   <span class="hljs-params">#</span>   |   <span class="hljs-params">#</span>   |   |   <span class="hljs-params">#</span><br>   <span class="hljs-params">#####</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span><br> 2 <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   |   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span><br>   <span class="hljs-params">#</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span><br> 3 <span class="hljs-params">#</span>   |   |   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span><br>   <span class="hljs-params">#</span>---<span class="hljs-params">#########</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span>---<span class="hljs-params">#</span><br> 4 <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   |   |   |   |   <span class="hljs-params">#</span>   <span class="hljs-params">#</span><br>   <span class="hljs-params">#############################</span><br>           (图 1)<br><br>   <span class="hljs-params">#</span>  = Wall   <br>   |  = No wall<br>   -  = No wall<br><br>   方向：上北下南左西右东。<br>图1是一个城堡的地形图。<br><br>请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。<br><br>城堡被分割成 m∗n个方格区域，每个方格区域可以有0~4面墙。<br><br>注意：墙体厚度忽略不计。<br><br>输入格式<br>第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。<br><br>接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。<br><br>每个方块中墙的特征由数字 P 来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P 为该方块包含墙的数字之和。<br><br>例如，如果一个方块的 P 为3，则 3 = 1 + 2，该方块包含西墙和北墙。<br><br>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。<br><br>输入的数据保证城堡至少有两个房间。<br><br>输出格式<br>共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。<br><br>数据范围<br>1≤m,n≤50,<br>0≤P≤15<br>输入样例：<br>4 7 <br>11 6 11 6 3 10 6 <br>7 9 6 13 5 15 5 <br>1 10 12 7 13 7 5 <br>13 11 10 8 10 12 13 <br>输出样例：<br>5<br>9<br></code></pre></td></tr></table></figure><p>这道题就是简介中讲的统计上下左右四个方向的，题目需要判断那一边有围墙，我们就定义一下4个方向，用位运算判断那个方向到底有没有围墙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>, M = N * N;<br>PII q[M];<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        PII t = q[hh ++];<br>        area ++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)&#123;<br>            <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[a][b])    <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[t.x][t.y] &gt;&gt; i &amp; <span class="hljs-number">1</span>)    <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判断有没有围墙</span><br>            q[++ tt] = &#123;a, b&#125;;<br>            st[a][b] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            cin &gt;&gt; g[i][j];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            <span class="hljs-keyword">if</span>(!st[i][j])&#123;<br>                area = <span class="hljs-built_in">max</span>(area, <span class="hljs-built_in">bfs</span>(i, j));<br>                cnt ++;<br>            &#125;<br>            <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    cout &lt;&lt; area &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1106-山峰和山谷"><a href="#3-1106-山峰和山谷" class="headerlink" title="3.1106. 山峰和山谷"></a>3.1106. <a href="https://www.acwing.com/problem/content/1108/">山峰和山谷</a></h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs latex">FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。<br><br>为了能够对旅程有一个安排，他想知道山峰和山谷的数量。<br><br>给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。<br><br>若两个格子有公共顶点，那么它们就是相邻的格子，如与 (i,j) 相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)。<br><br>我们定义一个格子的集合 S 为山峰（山谷）当且仅当：<br><br>S 的所有格子都有相同的高度。<br>S 的所有格子都连通。<br>对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws&gt;ws′（山峰），或者 ws&lt;ws′（山谷）。<br>如果周围不存在相邻区域，则同时将其视为山峰和山谷。<br>你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。<br><br>输入格式<br>第一行包含一个正整数 n，表示地图的大小。<br><br>接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。<br><br>输出格式<br>共一行，包含两个整数，表示山峰和山谷的数量。<br><br>数据范围<br>1≤n≤1000,<br>0≤w≤109<br>输入样例1：<br>5<br>8 8 8 7 7<br>7 7 8 8 7<br>7 7 7 7 7<br>7 8 8 7 8<br>7 8 8 8 8<br>输出样例1：<br>2 1<br>输入样例2：<br>5<br>5 7 8 3 1<br>5 5 7 6 6<br>6 6 6 2 8<br>5 7 2 5 8<br>7 1 0 1 7<br>输出样例2：<br>3 3<br></code></pre></td></tr></table></figure><p>这道题需要注意理解题意，即一片连通块没有比它高的就是山峰，然后就是山谷了，而且如果全部高度都一模一样，那么既是山峰也是山谷。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = N * N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N][N];<br>PII q[M];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">bool</span>&amp; has_higher, <span class="hljs-type">bool</span>&amp; has_lower)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        PII t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t.x - <span class="hljs-number">1</span>; i &lt;= t.x + <span class="hljs-number">1</span>; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t.y - <span class="hljs-number">1</span>; j &lt;= t.y + <span class="hljs-number">1</span>; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(i == t.x &amp;&amp; j == t.y)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= n)  <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(h[i][j] != h[t.x][t.y])&#123;<br>                    <span class="hljs-keyword">if</span>(h[i][j] &gt;= h[t.x][t.y])  has_higher = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> has_lower = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!st[i][j])&#123;<br>                    q[++ tt] = &#123;i, j&#125;;<br>                    st[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i][j]);<br><br>    <span class="hljs-type">int</span> peak = <span class="hljs-number">0</span>, valley = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[i][j])<br>            &#123;<br>                <span class="hljs-type">bool</span> has_higher = <span class="hljs-literal">false</span>, has_lower = <span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">bfs</span>(i, j, has_higher, has_lower);<br>                <span class="hljs-keyword">if</span> (!has_higher) peak ++ ;<br>                <span class="hljs-keyword">if</span> (!has_lower) valley ++ ;<br>            &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, peak, valley);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记1</title>
    <link href="/2022/08/01/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/08/01/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p align="center">    docker学习笔记</p><p>我们在开发过程中为了保证开发的环境能够保持一致，所以有了docker，保证无论在哪台电脑，都能保证开发环境的稳定。</p><p><strong>学习网站</strong></p><p>官网：<a href="https://www.docker.com/">www.docker.com</a></p><p>docker文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>关于docker使用的一些知识点</p><ul><li><p>很多docker命令都需要sudo权限，可以将当前用户添加到用户组里面，可以不用再写sudo了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure></li><li><p>docker里面有很多images，images就是镜像，images可以生成很多container(容器)，并且用相同镜像生成的容器的环境都一模一样</p></li><li><pre><code class="bash">docker pull ubuntu:20.04：拉取一个镜像docker images：列出本地所有镜像docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```bash<br><span class="hljs-title">  docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:</span><span class="hljs-number">20.04</span>导出到本地文件ubuntu_20_04.tar中<br>  并且该文件只有可读权限，可以给它增加可写权限<br>  chmod + r ubuntu_20_04.tar<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="bash">docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来 迁移到其他地方<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><br>- 关于容器(<span class="hljs-keyword">container</span>)的命令//中括号里面的是可以省略的意思<br><br>```bash<br>docker <span class="hljs-comment">[container]</span> create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。<br>docker ps -a：查看本地的所有容器<br>docker <span class="hljs-comment">[container]</span> start <span class="hljs-keyword">CONTAINER</span>：启动容器<br>docker <span class="hljs-comment">[container]</span> stop <span class="hljs-keyword">CONTAINER</span>：停止容器<br>docker <span class="hljs-comment">[container]</span> restart <span class="hljs-keyword">CONTAINER</span>：重启容器<br>docker <span class="hljs-comment">[contaienr]</span> run -itd ubuntu:20.04：创建并启动一个容器<br>docker <span class="hljs-comment">[container]</span> attach <span class="hljs-keyword">CONTAINER</span>：进入容器<br>先按Ctrl-p，再按Ctrl-q可以挂起容器<br>docker <span class="hljs-comment">[container]</span> exec <span class="hljs-keyword">CONTAINER</span> COMMAND：在容器中执行命令<br>docker <span class="hljs-comment">[container]</span> rm <span class="hljs-keyword">CONTAINER</span>：删除容器//删除容器之前得关掉容器<br>docker <span class="hljs-keyword">container</span> prune：删除所有已停止的容器<br>docker export -o xxx.tar <span class="hljs-keyword">CONTAINER</span>：将容器<span class="hljs-keyword">CONTAINER</span>导出到本地文件xxx.tar中<br>docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag<br>docker export/import与docker save/load的区别：<br>export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br>save/load会保存完整记录，体积更大<br>docker top <span class="hljs-keyword">CONTAINER</span>：查看某个容器内的所有进程<br>docker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息<br>docker cp xxx <span class="hljs-keyword">CONTAINER</span>:xxx 或 docker cp <span class="hljs-keyword">CONTAINER</span>:xxx xxx：在本地和容器间复制文件<br>docker rename CONTAINER1 CONTAINER2：重命名容器<br>docker update <span class="hljs-keyword">CONTAINER</span> --memory 500MB：修改容器限制<br></code></pre></td></tr></table></figure></code></pre></li><li><p>两个云服务器之间不能直接传docker</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/2022/07/31/My-New-Post/"/>
    <url>/2022/07/31/My-New-Post/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/31/My-New-Post/%E4%BD%9C%E4%B8%9A1.4.0.png" class>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode11</title>
    <link href="/2022/07/30/Leetcode11/"/>
    <url>/2022/07/30/Leetcode11/</url>
    
    <content type="html"><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>双指针算法，用两个指针 i,j分别指向首尾，如果 ai&gt;aj，则 j−−；否则 i++，直到 i&#x3D;j为止，每次迭代更新最大值。</p><img src="/2022/07/30/Leetcode11/image-20220305105220834.png" class><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; )<span class="hljs-comment">//注意最后的分号，这是跳出循环的关键</span><br>        &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>            <span class="hljs-keyword">if</span> (height[i] &gt; height[j]) j -- ;<br>            <span class="hljs-keyword">else</span> i ++ ;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/30/hello-world/"/>
    <url>/2022/07/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
