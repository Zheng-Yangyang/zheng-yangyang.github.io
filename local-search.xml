<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>周赛01</title>
    <link href="/2022/08/07/%E5%91%A8%E8%B5%9B01/"/>
    <url>/2022/08/07/%E5%91%A8%E8%B5%9B01/</url>
    
    <content type="html"><![CDATA[<h4 id="AcWing周赛"><a href="#AcWing周赛" class="headerlink" title="AcWing周赛"></a>AcWing周赛</h4><h5 id="4503-数对数量"><a href="#4503-数对数量" class="headerlink" title="4503.数对数量"></a>4503.<a href="https://www.acwing.com/problem/content/4506/">数对数量</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex">请计算，共有多少个整数数对 (x,y) 同时满足：<br><br>0≤x≤a<br>0≤y≤b<br>x+y=n<br>例如，当 a=5,b=6,n=3 时，共有 4 个满足条件的数对：(0,3),(1,2),(2,1),(3,0)。<br><br>输入格式<br>第一行包含整数 a。<br><br>第二行包含整数 b。<br><br>第三行包含整数 n。<br><br>输出格式<br>一个整数，表示满足条件的数对数量。<br><br>数据范围<br>前三个测试点满足 1≤a,b≤10，1≤n≤a+b。<br>所有测试点满足 1≤a,b≤300，1≤n≤a+b。<br><br>输入样例1：<br>5<br>6<br>3<br>输出样例1：<br>4<br>输入样例2：<br>5<br>3<br>5<br>输出样例2：<br>4<br></code></pre></td></tr></table></figure><p>思路：直接模拟即可，需要注意的是(0, 3) 和(3, 0)是两个不同的答案，所以不用担心去重，我傻逼了还考虑去重，用了个set＋pair 发现不用去重。两种代码都存一下吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>直接法<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, n;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= a; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= b; j ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i + j == n)  res ++;<br>        &#125;<br>        <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-number">2.</span>set&lt;pair&gt; 法<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, n;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;<br>    set&lt;PII&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= a; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= b; j ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i + j == n)  st.<span class="hljs-built_in">insert</span>(&#123;i, j&#125;);<br>        &#125;<br>        <br>    cout &lt;&lt; st.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure><h5 id="4504-字符串消除"><a href="#4504-字符串消除" class="headerlink" title="4504.字符串消除"></a>4504.<a href="https://www.acwing.com/problem/content/4507/">字符串消除</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex">李华和张红正在玩字符串消除游戏。<br><br>游戏规则如下：<br><br>给定一个由小写字母构成的字符串 s。<br>两人轮流进行消除操作，当轮到一人时，其任务是在当前 s 中找到两个连续且相同的字母，并将它们从 s 中消除。例如，当 s 为 abba 时，可以消除 bb，使 s 变为 aa。<br>第一个无法进行消除操作的选手视为失败。<br>已知，游戏由李华执先手，且两人都采取最优策略。<br><br>请问，李华是否可以获胜。<br><br>输入格式<br>一行，一个字符串 s。<br><br>输出格式<br>如果李华可以获胜，则输出 Yes，否则输出 No。<br><br>数据范围<br>前 5 个测试点满足 1≤|s|≤10。<br>所有测试点满足 1≤|s|≤105。<br><br>输入样例1：<br>abacaba<br>输出样例1：<br>No<br>输入样例2：<br>iiq<br>输出样例2：<br>Yes<br>输入样例3：<br>abba<br>输出样例3：<br>No<br></code></pre></td></tr></table></figure><p>思路：刚开始看到这道题很懵，然后想到了有点像的一道题，括号序列<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a> 可以去看看这道题的题解，然后就想到了用栈来解决这个问题。刚开始被那道题的思路带到了，一位还是得判断栈是不是空，后来发现需要求解的是操作的次数是奇数还是偶数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>    stk.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">size</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == s[i])    &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>            cnt ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(s[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4505-最大子集"><a href="#4505-最大子集" class="headerlink" title="4505.最大子集"></a>4505.最大子集</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs latex">给定一个包含 n 个元素的整数集合。<br><br>集合中的元素两两不同。<br><br>请你找到一个该集合的最大子集，要求子集内的元素满足任意两元素之差的绝对值都是 2 的整数幂。<br><br>注意，只包含 1 个元素的子集一定满足条件。<br><br>输入格式<br>第一行包含整数 n。<br><br>第二行包含 n 个两两不同的整数 x1,x2,…,xn。<br><br>输出格式<br>第一行输出一个整数 m，表示满足条件的最大子集包含的元素数量。<br><br>第二行包含 m 个整数，表示最大子集中包含的元素。<br><br>如果方案不唯一，则输出任意合理方案均可。<br><br>数据范围<br>前 6 个测试点满足 1≤n≤10。<br>所有测试点满足 1≤n≤2×105，−109≤xi≤109。<br><br>注意：本题数据范围较大，慎用cin/cout、unordered<span class="hljs-built_in">_</span>set、unordered<span class="hljs-built_in">_</span>map等操作。<br><br>输入样例1：<br>6<br>3 5 4 7 10 12<br>输出样例1：<br>3<br>7 3 5<br>输入样例2：<br>5<br>-1 2 5 8 11<br>输出样例2：<br>1<br>8<br></code></pre></td></tr></table></figure><p>思路：</p><p>昨天第二次a了两题，然后第三题就没有心思考虑了，后面发现第三题仔细思考还是有很多可取之处的。</p><p>下面来看看y总是如何分析的。从下面的截图可以看出，要使等式成立，y必须等于x，z也必须等于y，所以这三个就是等差数列，这是三个数的情况，如果是4个数的话，最大的数减去最小的数就是$3*2^{x}$,必然不是$2^k$,而且也可以推出，如果超过4个数也会有类似的矛盾.所以可以发现只有三个数，所以可以直接枚举三个来分析。所以最多有三个，最少有一个。又由于这道题卡常数，需要手写哈希表</p><img src="/2022/08/07/%E5%91%A8%E8%B5%9B01/image-20220807134352465.png" class title="image-20220807134352465"><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-params">#</span>include &lt;iostream&gt;<br><span class="hljs-params">#</span>include &lt;cstring&gt;<br><span class="hljs-params">#</span>include &lt;algorithm&gt;<br>using namespace std;<br>const int N = 200010, M = 1999997, INF = 0x3f3f3f3f;//M为哈希表的长度，一般开个五六倍以上<br>int q[N], h[M];<br>int find(int x)&#123;<br>    int t = (x <span class="hljs-comment">% M + M) % M;</span><br>    while (h[t] != INF <span class="hljs-built_in">&amp;</span><span class="hljs-built_in">&amp;</span> h[t] != x)<br>        if ( ++ t == M)<br>            t = 0;<br>    return t;<br>    <br>&#125;<br><br><br>int main()<br>&#123;<br>    int n;<br>    scanf(&quot;<span class="hljs-comment">%d&quot;, &amp;n);</span><br>    for(int i = 0; i &lt; n; i ++) scanf(&quot;<span class="hljs-comment">%d&quot;, &amp;q[i]);</span><br>    sort(q, q + n);<br>    memset(h, 0x3f, sizeof h);//初始化哈希表，用正无穷这个特殊值来表示<br>    int res[3], s[3];<br>    int rt = 0, st = 0; //rt为集合长度，st为集合长度为3的集合长度<br>    for (int i = 0; i &lt; n; i ++ )<br>    &#123;<br>        for (int j = 0; j &lt;= 30; j ++ )<br>        &#123;<br>            int d = 1 &lt;&lt; j;//公差<br>            s[0] = q[i], st = 1;//集合初始有q[i]这个数<br>            for (int k = 1; k &lt;= 2; k ++ )<br>            &#123;<br>                int x = q[i] - d * k;<br>                if (h[find(x)] == INF) break;//表示不存在<br>                s[st ++ ] = x;<br>            &#125;<br>            if (rt &lt; st)<br>            &#123;<br>                rt = st;<br>                memcpy(res, s, sizeof s);<br>                if (rt == 3) break;<br>            &#125;<br>        &#125;<br>        if (rt == 3) break;<br>        h[find(q[i])] = q[i];<br>    &#125;<br>    printf(&quot;<span class="hljs-comment">%d\n&quot;, rt);</span><br>    for (int i = 0; i &lt; rt; i ++ )<br>        printf(&quot;<span class="hljs-comment">%d &quot;, res[i]);</span><br>    return 0;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LeetCode第84场双周赛"><a href="#LeetCode第84场双周赛" class="headerlink" title="LeetCode第84场双周赛"></a>LeetCode第84场双周赛</h4><h5 id="6141-合并相似的物品"><a href="#6141-合并相似的物品" class="headerlink" title="6141. 合并相似的物品"></a>6141. 合并相似的物品</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：<br><br>items[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。<br>items 中每件物品的价值都是 唯一的 。<br>请你返回一个二维数组 ret，其中 ret[i] = [valuei, weighti]， weighti 是所有价值为 valuei 物品的 重量之和 。<br><br>注意：ret 应该按价值 升序 排序后返回。<br><br> <br><br>示例 1：<br><br>输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]<br>输出：[[1,6],[3,9],[4,5]]<br>解释：<br>value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。<br>value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。<br>value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。<br>所以，我们返回 [[1,6],[3,9],[4,5]] 。<br>示例 2：<br><br>输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]<br>输出：[[1,4],[2,4],[3,4]]<br>解释：<br>value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。<br>value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。<br>value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。<br>所以，我们返回 [[1,4],[2,4],[3,4]] 。<br>示例 3：<br><br>输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]<br>输出：[[1,7],[2,4],[7,1]]<br>解释：<br>value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。<br>value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。<br>value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。<br>所以，我们返回 [[1,7],[2,4],[7,1]] 。<br> <br><br>提示：<br><br>1 &lt;= items1.length, items2.length &lt;= 1000<br>items1[i].length == items2[i].length == 2<br>1 &lt;= valuei, weighti &lt;= 1000<br>items1 中每个 valuei 都是 唯一的 。<br>items2 中每个 valuei 都是 唯一的 。<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/merge-similar-items<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：两个思路。第一个思路：用map存对应的关键值和数量，然后，由于map本来就是有序的所以可以直接输出</p><p>​第二个思路：排序+归并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map做法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items2) &#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : items1) hash[item[<span class="hljs-number">0</span>]] += item[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : items2) hash[item[<span class="hljs-number">0</span>]] += item[<span class="hljs-number">1</span>];<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [k, v] : hash)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(&#123;k, v&#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br>排序+归并做法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; items2) &#123;<br>        <span class="hljs-built_in">sort</span>(items1.<span class="hljs-built_in">begin</span>(), items1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(items2.<span class="hljs-built_in">begin</span>(), items2.<span class="hljs-built_in">end</span>());<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; items1.<span class="hljs-built_in">size</span>() || j &lt; items2.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (j == items2.<span class="hljs-built_in">size</span>()) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(items1[i]);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == items1.<span class="hljs-built_in">size</span>()) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(items2[j]);<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (items1[i][<span class="hljs-number">0</span>] &lt; items2[j][<span class="hljs-number">0</span>]) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(items1[i]);<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (items1[i][<span class="hljs-number">0</span>] &gt; items2[j][<span class="hljs-number">0</span>]) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(items2[j]);<br>                    j++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;items1[i][<span class="hljs-number">0</span>], items1[i][<span class="hljs-number">1</span>] + items2[j][<span class="hljs-number">1</span>]&#125;);<br>                    i++;<br>                    j++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;    <br></code></pre></td></tr></table></figure><h5 id="6142-统计坏数对的数目"><a href="#6142-统计坏数对的数目" class="headerlink" title="6142. 统计坏数对的数目"></a><a href="https://leetcode.cn/problems/count-number-of-bad-pairs/">6142. 统计坏数对的数目</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你一个下标从 0 开始的整数数组 nums 。如果 i &lt; j 且 j - i != nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。<br><br>请你返回 nums 中 坏数对 的总数目。<br><br> <br><br>示例 1：<br><br>输入：nums = [4,1,3,3]<br>输出：5<br>解释：数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。<br>数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。<br>数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。<br>数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。<br>数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。<br>总共有 5 个坏数对，所以我们返回 5 。<br>示例 2：<br><br>输入：nums = [1,2,3,4,5]<br>输出：0<br>解释：没有坏数对。<br> <br><br>提示：<br><br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 109<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/count-number-of-bad-pairs<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：我们可以发现将上面的条件互换，就可以构造一个新的数组，并且该数组是 nums[i] - i 组成的，然后我们再在该数组中排列组合求得好数对的个数。用总的数对个数减去好数对的个数，就是坏数对的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x * (x - <span class="hljs-number">1LL</span>)/<span class="hljs-number">2</span>;  <span class="hljs-comment">//1LL 可以自动转换成LL类型的数据</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countBadPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        LL res = <span class="hljs-built_in">C</span>(n);<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            hash[nums[i] - i] ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [k, v] : hash)&#123;<br>            res -= <span class="hljs-built_in">C</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="6174-任务调度器-II"><a href="#6174-任务调度器-II" class="headerlink" title="6174. 任务调度器 II"></a><a href="https://leetcode.cn/problems/task-scheduler-ii/">6174. 任务调度器 II</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。<br><br>同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。<br><br>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：<br><br>完成 tasks 中的下一个任务<br>休息一天<br>请你返回完成所有任务所需的 最少 天数。<br><br> <br><br>示例 1：<br><br>输入：tasks = [1,2,1,2,3,1], space = 3<br>输出：9<br>解释：<br>9 天完成所有任务的一种方法是：<br>第 1 天：完成任务 0 。<br>第 2 天：完成任务 1 。<br>第 3 天：休息。<br>第 4 天：休息。<br>第 5 天：完成任务 2 。<br>第 6 天：完成任务 3 。<br>第 7 天：休息。<br>第 8 天：完成任务 4 。<br>第 9 天：完成任务 5 。<br>可以证明无法少于 9 天完成所有任务。<br>示例 2：<br><br>输入：tasks = [5,8,8,5], space = 2<br>输出：6<br>解释：<br>6 天完成所有任务的一种方法是：<br>第 1 天：完成任务 0 。<br>第 2 天：完成任务 1 。<br>第 3 天：休息。<br>第 4 天：休息。<br>第 5 天：完成任务 2 。<br>第 6 天：完成任务 3 。<br>可以证明无法少于 6 天完成所有任务。<br> <br><br>提示：<br><br>1 &lt;= tasks.length &lt;= 105<br>1 &lt;= tasks[i] &lt;= 109<br>1 &lt;= space &lt;= tasks.length<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/task-scheduler-ii<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：可以证明每次任务越早完成越好，而且每次同种类型完成的人物需要比上一次完成同样的人物多space + 1 天，用一个哈希表记录上次任务完成的天数，然后再分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">taskSchedulerII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; tasks, <span class="hljs-type">int</span> space)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = tasks.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, LL&gt; hash;<br>        LL res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : tasks)&#123;<br>            res = <span class="hljs-built_in">max</span>(res + <span class="hljs-number">1</span>, hash[x]);<br>            hash[x] = res + space + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="6144-将数组排序的最少替换次数"><a href="#6144-将数组排序的最少替换次数" class="headerlink" title="6144. 将数组排序的最少替换次数"></a><a href="https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/">6144. 将数组排序的最少替换次数</a></h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">给你一个下表从 0 开始的整数数组 nums 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。<br><br>比方说，nums = [5,6,7] 。一次操作中，我们可以将 nums[1] 替换成 2 和 4 ，将 nums 转变成 [5,2,4,7] 。<br>请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。<br><br> <br><br>示例 1：<br><br>输入：nums = [3,9,3]<br>输出：2<br>解释：以下是将数组变成非递减顺序的步骤：<br>- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] <br>- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] <br>总共需要 2 步将数组变成非递减有序，所以我们返回 2 。<br>示例 2：<br><br>输入：nums = [1,2,3,4,5]<br>输出：0<br>解释：数组已经是非递减顺序，所以我们返回 0 。<br> <br><br>提示：<br><br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 109<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/minimum-replacements-to-sort-the-array<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>思路：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">贪心) O(n)<br>注意到，数字只会越拆分越小，所以需要对较大的数字下手。<br>从数组末尾开始往前寻找，找到第一个非递减顺序的位置 p，满足 p&gt;0 且 nums(p)&lt;nums(p−1)。<br>如果 p 不存在，则说明数组已经是非递减顺序，直接返回。<br>定义最大可保留的数字为 target，初始化 target:=nums(p)。从 p−1 开始倒序拆分。<br>如果 nums(i) mod target=0，则说明 nums(i) 可以完全拆分为若干个 target，则答案增加 nums(i)/target−1，并且 target 保持不变。<br>否则，拆分的最少次数就是 c:=nums(i)/target 次，但拆分为 c+1 个数字后需要尽可能的让最小的数字最大（作为下一次拆分的 target），此时最小数字的最大可能值为 target:=nums(i)/(c+1)。<br>注意到，两种情况可以合到一起处理，即直接从数组末尾开始计算。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">LL <span class="hljs-title">minimumReplacement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        LL ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> target = nums[n - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> c = nums[i] / target;<br><br>            <span class="hljs-keyword">if</span> (nums[i] % target == <span class="hljs-number">0</span>) &#123;<br>                ans += c - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += c;<br>                target = nums[i] / (c + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS_0.1</title>
    <link href="/2022/08/05/DFS-0-1/"/>
    <url>/2022/08/05/DFS-0-1/</url>
    
    <content type="html"><![CDATA[<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>分析dfs常见的两种模型，第一个是连通性模型，第二个是搜索顺序模型。在DFS中，一个很容易搞错的事情就是需不需要恢复现场，但是我们这样分析的话，就很容易。我们把dfs分成两种，第一种就是只是求内部的数据，比如从一个点到另一个点，这种题目就不需要恢复现场，另外一种就是外部实现的。比如我们要列举不同的形成方案，这种的题目，我们可以想一想，每次形成新的方案的时候就需要恢复现场。</p><h5 id="DFS性质简述版"><a href="#DFS性质简述版" class="headerlink" title="DFS性质简述版"></a>DFS性质简述版</h5><p>可以仔细区别下面两种模型，我们可以发现第一种模型都不需要恢复状态，第二种都需要恢复，我们把第一种称为内部搜索，第二种称为外部搜索。</p><p>DFS的具体步骤：</p><p>先找到开始的状态，确定需要求的东西是什么，是块数还是个数。然后后面的步骤就和bfs很像了，先去判断掉错误情况，然后再需要去寻找递归状态。有些dfs需要加剪枝去除重复和冗余状态，在这里就没怎么讲解，后面会有一个dfs_0.2讲解带剪枝的版本。</p><h5 id="DFS之连通性模型"><a href="#DFS之连通性模型" class="headerlink" title="DFS之连通性模型"></a>DFS之连通性模型</h5><p>1112.<a href="https://www.acwing.com/problem/content/1114/">迷宫</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs latex">一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由 n∗n 的格点组成，每个格点只有2种状态，.和<span class="hljs-params">#</span>，前者表示可以通行后者表示不能通行。<br><br>同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。<br><br>如果起点或者终点有一个不能通行(为<span class="hljs-params">#</span>)，则看成无法办到。<br><br>注意：A、B不一定是两个不同的点。<br><br>输入格式<br>第1行是测试数据的组数 k，后面跟着 k 组输入。<br><br>每组测试数据的第1行是一个正整数 n，表示迷宫的规模是 n∗n 的。<br><br>接下来是一个 n∗n 的矩阵，矩阵中的元素为.或者<span class="hljs-params">#</span>。<br><br>再接下来一行是 4 个整数 ha,la,hb,lb，描述 A 处在第 ha 行, 第 la 列，B 处在第 hb 行, 第 lb 列。<br><br>注意到 ha,la,hb,lb 全部是从 0 开始计数的。<br><br>输出格式<br>k行，每行输出对应一个输入。<br><br>能办到则输出“YES”，否则输出“NO”。<br><br>数据范围<br>1≤n≤100<br>输入样例：<br>2<br>3<br>.<span class="hljs-params">##</span><br>..<span class="hljs-params">#</span><br><span class="hljs-params">#</span>..<br>0 0 2 2<br>5<br>.....<br><span class="hljs-params">###</span>.<span class="hljs-params">#</span><br>..<span class="hljs-params">#</span>..<br><span class="hljs-params">###</span>..<br>...<span class="hljs-params">#</span>.<br>0 0 4 0<br>输出样例:<br>YES<br>NO<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> xa, xb, ya, yb;<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(x == xb &amp;&amp; y == yb)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    st[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)&#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(a, b))   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;xa, &amp;ya, &amp;xb, &amp;yb);<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<span class="hljs-comment">//每次需要重置状态数组</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(xa, ya)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1113.<a href="https://www.acwing.com/problem/content/1115/">红与黑</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs latex">有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。<br><br>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。<br><br>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。<br><br>输入格式<br>输入包括多个数据集合。<br><br>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。<br><br>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下<br><br>1）‘.’：黑色的瓷砖；<br>2）‘<span class="hljs-params">#</span>’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。<br><br>当在一行中读入的是两个零时，表示输入结束。<br><br>输出格式<br>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。<br><br>数据范围<br>1≤W,H≤20<br>输入样例：<br>6 9 <br>....<span class="hljs-params">#</span>. <br>.....<span class="hljs-params">#</span> <br>...... <br>...... <br>...... <br>...... <br>...... <br><span class="hljs-params">#</span>@...<span class="hljs-params">#</span> <br>.<span class="hljs-params">#</span>..<span class="hljs-params">#</span>. <br>0 0<br>输出样例：<br>45<br></code></pre></td></tr></table></figure><p>这道题用dfs和bfs实现了，可以看看他们之间的区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dfs版本<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    st[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(g[a][b] != <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>        cnt += <span class="hljs-built_in">dfs</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; m &gt;&gt; n , n || m)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)  <br>                    x = i, y = j;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(x, y) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br>bfs版本<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25</span>, M = N * N;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br>PII q[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)<br>    &#123;<br>        PII t = q[hh ++];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[a][b] != <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[a][b])    <span class="hljs-keyword">continue</span>;<br>            q[++ tt] = &#123;a, b&#125;;<br>            st[a][b] = <span class="hljs-literal">true</span>;<br>            cnt ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; m &gt;&gt; n , n || m)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)  <br>                    x = i, y = j;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        cout &lt;&lt; <span class="hljs-built_in">bfs</span>(x, y) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="DFS之搜索顺序"><a href="#DFS之搜索顺序" class="headerlink" title="DFS之搜索顺序"></a>DFS之搜索顺序</h5><p>1116.<a href="https://www.acwing.com/problem/content/description/1118/">马走日</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs latex">马在中国象棋以日字形规则移动。<br><br>请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。<br><br>输入格式<br>第一行为整数 T，表示测试数据组数。<br><br>每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。<br><br>输出格式<br>每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。<br><br>数据范围<br>1≤T≤9,<br>1≤m,n≤9,<br>1≤n×m≤28,<br>0≤x≤n−1,<br>0≤y≤m−1<br>输入样例：<br>1<br>5 4 0 0<br>输出样例：<br>32<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cnt == n * m)<br>    &#123;<br>        ans ++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    st[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b])    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(a, b, cnt + <span class="hljs-number">1</span>);<br>    &#125;<br>    st[x][y] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y);<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        ans = <span class="hljs-number">0</span>;<span class="hljs-comment">//这个必须加上，因为每一组数据都需要重新清空</span><br>        <span class="hljs-built_in">dfs</span>(x, y, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>1117.<a href="https://www.acwing.com/problem/content/1119/">单词接龙</a></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">单词接龙是一个与我们经常玩的成语接龙相类似的游戏。<br><br>现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。<br><br>在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。<br><br>我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。<br><br>输入格式<br>输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。<br><br>你可以假定以此字母开头的“龙”一定存在。<br><br>输出格式<br>只需输出以此字母开头的最长的“龙”的长度。<br><br>数据范围<br>n≤20<br>输入样例：<br>5<br>at<br>touch<br>cheat<br>choose<br>tact<br>a<br>输出样例：<br>23<br>提示<br>连成的“龙”为 atoucheatactactouchoose。<br></code></pre></td></tr></table></figure><p>这道题需要多看看几次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><span class="hljs-type">int</span> n;<br>string word[N];<br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">// 编号为i的字符串与编号为j的字符串拼接的长度如i：asd，j：sdf，拼接长度为最小值g[i][j] = 2</span><br><span class="hljs-type">int</span> used[N];<span class="hljs-comment">//编号为i的单词使用次数</span><br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string dragon, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function"></span>&#123;<br>    ans = <span class="hljs-built_in">max</span>((<span class="hljs-type">int</span>)dragon.<span class="hljs-built_in">size</span>(), ans);<br>    used[last] ++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(g[last][i] &amp;&amp; used[i] &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(dragon + word[i].<span class="hljs-built_in">substr</span>(g[last][i]), i);<br>        &#125;<br>        <br>    &#125;<br>    used[last] --;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; word[i];<br>    <span class="hljs-type">char</span> start;<br>    cin &gt;&gt; start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>            string a = word[i], b = word[j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-built_in">min</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>()); k ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">substr</span>(a.<span class="hljs-built_in">size</span>() - k, k) == b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k))&#123;<br>                    g[i][j] = k;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(word[i][<span class="hljs-number">0</span>] == start)<br>                <span class="hljs-built_in">dfs</span>(word[i], i);<br>        &#125;<br>        cout &lt;&lt; ans;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS中floodfill算法总结</title>
    <link href="/2022/08/02/BFS%E4%B8%ADfloodfill%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/02/BFS%E4%B8%ADfloodfill%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="关于bfs中的floodfill算法总结"><a href="#关于bfs中的floodfill算法总结" class="headerlink" title="关于bfs中的floodfill算法总结"></a>关于bfs中的floodfill算法总结</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>floodfill 是宽度优先搜索中一个经典模型，用来判断连通块的数量以及一些其他性质。但其本质还是宽度优先搜索</p><img src="/2022/08/02/BFS%E4%B8%ADfloodfill%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/floodfill.png" class><h4 id="flood算法过程简介"><a href="#flood算法过程简介" class="headerlink" title="flood算法过程简介"></a>flood算法过程简介</h4><p>首先宽度优先搜索都是需要用队列完成，所以一般都是用数组模拟队列去完成，然后由于要保存两个信息，自然就有了定义pair等操作，为了保证是线性的复杂度，所以一个状态数组也是必不可少的。还有一点需要注意的是，注意读入的是字符还是整型。不然答案错了很难debug出来</p><p>接着是具体步骤。前面的操作都是相同的，将该点放入队列，然后标记该点已被使用，接下来就是队列不空的操作，取出队列头操作。接下来需要分两种，一种是统计周围八个元素的，这种情况，我们一般写一个二重循环来判断，接着最重要也是最容易出错的，就是判断哪些情况需要特判掉，比如数组刚好等于要遍历的那个点，数组越界，该点已经被用过(标记过)，还有不同条件的具体要求。判断所有条件之后，然后就需要将这个点加入队尾，然后标记这个点用过。第二种情况是统计周围四个元素的，这种一般定义一个dx和dy数组，分别表示上下左右四个方向，然后再去求后面的操作。</p><h4 id="1-1097-池塘计数"><a href="#1-1097-池塘计数" class="headerlink" title="1.1097. 池塘计数"></a>1.1097. <a href="https://www.acwing.com/problem/content/1099/">池塘计数</a></h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs latex">农夫约翰有一片 N∗M 的矩形土地。<br><br>最近，由于降雨的原因，部分土地被水淹没了。<br><br>现在用一个字符矩阵来表示他的土地。<br><br>每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。<br><br>现在，约翰想知道他的土地中形成了多少片池塘。<br><br>每组相连的积水单元格集合可以看作是一片池塘。<br><br>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。<br><br>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。<br><br>输入格式<br>第一行包含两个整数 N 和 M。<br><br>接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。<br><br>输出格式<br>输出一个整数，表示池塘数目。<br><br>数据范围<br>1≤N,M≤1000<br>输入样例：<br>10 12<br>W........WW.<br>.WWW.....WWW<br>....WW...WW.<br>.........WW.<br>.........W..<br>..W......W..<br>.W.W.....WW.<br>W.W.W.....W.<br>.W.W......W.<br>..W.......W.<br>输出样例：<br>3<br></code></pre></td></tr></table></figure><p>最基础的floodfill算法，只是统计连通块的数量的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = N * N;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br>PII q[M];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        PII t = q[hh ++]; <span class="hljs-comment">// 取出队头</span><br>        <span class="hljs-comment">//遍历周围八个元素可以用一个二重循环来写</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t.x - <span class="hljs-number">1</span>; i &lt;= t.x + <span class="hljs-number">1</span>; i ++)<span class="hljs-comment">//注意是需要有等号的</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t.y - <span class="hljs-number">1</span>; j &lt;= t.y + <span class="hljs-number">1</span>; j ++)&#123;<span class="hljs-comment">//注意那些需要特判掉的情况不要漏掉</span><br>                <span class="hljs-keyword">if</span>(i == t.x &amp;&amp; j == t.y)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= m)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(st[i][j])    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>                q[++ tt] = &#123;i, j&#125;;<br>                st[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);  <span class="hljs-comment">//可以一排直接读一个字符串，不用二重循环 而且读s不需要加取址</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st[i][j] &amp;&amp; g[i][j] == <span class="hljs-string">&#x27;W&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">bfs</span>(i, j);<br>                        cnt ++;<br>                    &#125;<br>            &#125;<br>            <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <br>        <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1098-城堡问题"><a href="#2-1098-城堡问题" class="headerlink" title="2.1098. 城堡问题"></a>2.1098. <a href="https://www.acwing.com/problem/content/1100/">城堡问题</a></h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs latex"> 1   2   3   4   5   6   7  <br>   <span class="hljs-params">#############################</span><br> 1 <span class="hljs-params">#</span>   |   <span class="hljs-params">#</span>   |   <span class="hljs-params">#</span>   |   |   <span class="hljs-params">#</span><br>   <span class="hljs-params">#####</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span><br> 2 <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   |   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span><br>   <span class="hljs-params">#</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span><br> 3 <span class="hljs-params">#</span>   |   |   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   <span class="hljs-params">#</span><br>   <span class="hljs-params">#</span>---<span class="hljs-params">#########</span>---<span class="hljs-params">#####</span>---<span class="hljs-params">#</span>---<span class="hljs-params">#</span><br> 4 <span class="hljs-params">#</span>   <span class="hljs-params">#</span>   |   |   |   |   <span class="hljs-params">#</span>   <span class="hljs-params">#</span><br>   <span class="hljs-params">#############################</span><br>           (图 1)<br><br>   <span class="hljs-params">#</span>  = Wall   <br>   |  = No wall<br>   -  = No wall<br><br>   方向：上北下南左西右东。<br>图1是一个城堡的地形图。<br><br>请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。<br><br>城堡被分割成 m∗n个方格区域，每个方格区域可以有0~4面墙。<br><br>注意：墙体厚度忽略不计。<br><br>输入格式<br>第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。<br><br>接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。<br><br>每个方块中墙的特征由数字 P 来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P 为该方块包含墙的数字之和。<br><br>例如，如果一个方块的 P 为3，则 3 = 1 + 2，该方块包含西墙和北墙。<br><br>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。<br><br>输入的数据保证城堡至少有两个房间。<br><br>输出格式<br>共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。<br><br>数据范围<br>1≤m,n≤50,<br>0≤P≤15<br>输入样例：<br>4 7 <br>11 6 11 6 3 10 6 <br>7 9 6 13 5 15 5 <br>1 10 12 7 13 7 5 <br>13 11 10 8 10 12 13 <br>输出样例：<br>5<br>9<br></code></pre></td></tr></table></figure><p>这道题就是简介中讲的统计上下左右四个方向的，题目需要判断那一边有围墙，我们就定义一下4个方向，用位运算判断那个方向到底有没有围墙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>, M = N * N;<br>PII q[M];<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        PII t = q[hh ++];<br>        area ++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)&#123;<br>            <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(st[a][b])    <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[t.x][t.y] &gt;&gt; i &amp; <span class="hljs-number">1</span>)    <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判断有没有围墙</span><br>            q[++ tt] = &#123;a, b&#125;;<br>            st[a][b] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            cin &gt;&gt; g[i][j];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            <span class="hljs-keyword">if</span>(!st[i][j])&#123;<br>                area = <span class="hljs-built_in">max</span>(area, <span class="hljs-built_in">bfs</span>(i, j));<br>                cnt ++;<br>            &#125;<br>            <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    cout &lt;&lt; area &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1106-山峰和山谷"><a href="#3-1106-山峰和山谷" class="headerlink" title="3.1106. 山峰和山谷"></a>3.1106. <a href="https://www.acwing.com/problem/content/1108/">山峰和山谷</a></h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs latex">FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。<br><br>为了能够对旅程有一个安排，他想知道山峰和山谷的数量。<br><br>给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。<br><br>若两个格子有公共顶点，那么它们就是相邻的格子，如与 (i,j) 相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)。<br><br>我们定义一个格子的集合 S 为山峰（山谷）当且仅当：<br><br>S 的所有格子都有相同的高度。<br>S 的所有格子都连通。<br>对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws&gt;ws′（山峰），或者 ws&lt;ws′（山谷）。<br>如果周围不存在相邻区域，则同时将其视为山峰和山谷。<br>你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。<br><br>输入格式<br>第一行包含一个正整数 n，表示地图的大小。<br><br>接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。<br><br>输出格式<br>共一行，包含两个整数，表示山峰和山谷的数量。<br><br>数据范围<br>1≤n≤1000,<br>0≤w≤109<br>输入样例1：<br>5<br>8 8 8 7 7<br>7 7 8 8 7<br>7 7 7 7 7<br>7 8 8 7 8<br>7 8 8 8 8<br>输出样例1：<br>2 1<br>输入样例2：<br>5<br>5 7 8 3 1<br>5 5 7 6 6<br>6 6 6 2 8<br>5 7 2 5 8<br>7 1 0 1 7<br>输出样例2：<br>3 3<br></code></pre></td></tr></table></figure><p>这道题需要注意理解题意，即一片连通块没有比它高的就是山峰，然后就是山谷了，而且如果全部高度都一模一样，那么既是山峰也是山谷。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = N * N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N][N];<br>PII q[M];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">bool</span>&amp; has_higher, <span class="hljs-type">bool</span>&amp; has_lower)</span></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = &#123;sx, sy&#125;;<br>    st[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        PII t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t.x - <span class="hljs-number">1</span>; i &lt;= t.x + <span class="hljs-number">1</span>; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t.y - <span class="hljs-number">1</span>; j &lt;= t.y + <span class="hljs-number">1</span>; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(i == t.x &amp;&amp; j == t.y)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= n)  <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(h[i][j] != h[t.x][t.y])&#123;<br>                    <span class="hljs-keyword">if</span>(h[i][j] &gt;= h[t.x][t.y])  has_higher = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> has_lower = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!st[i][j])&#123;<br>                    q[++ tt] = &#123;i, j&#125;;<br>                    st[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i][j]);<br><br>    <span class="hljs-type">int</span> peak = <span class="hljs-number">0</span>, valley = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[i][j])<br>            &#123;<br>                <span class="hljs-type">bool</span> has_higher = <span class="hljs-literal">false</span>, has_lower = <span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">bfs</span>(i, j, has_higher, has_lower);<br>                <span class="hljs-keyword">if</span> (!has_higher) peak ++ ;<br>                <span class="hljs-keyword">if</span> (!has_lower) valley ++ ;<br>            &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, peak, valley);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记1</title>
    <link href="/2022/08/01/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/08/01/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p align="center">    docker学习笔记</p><p>我们在开发过程中为了保证开发的环境能够保持一致，所以有了docker，保证无论在哪台电脑，都能保证开发环境的稳定。</p><p><strong>学习网站</strong></p><p>官网：<a href="https://www.docker.com/">www.docker.com</a></p><p>docker文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>关于docker使用的一些知识点</p><ul><li><p>很多docker命令都需要sudo权限，可以将当前用户添加到用户组里面，可以不用再写sudo了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure></li><li><p>docker里面有很多images，images就是镜像，images可以生成很多container(容器)，并且用相同镜像生成的容器的环境都一模一样</p></li><li><pre><code class="bash">docker pull ubuntu:20.04：拉取一个镜像docker images：列出本地所有镜像docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```bash<br><span class="hljs-title">  docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:</span><span class="hljs-number">20.04</span>导出到本地文件ubuntu_20_04.tar中<br>  并且该文件只有可读权限，可以给它增加可写权限<br>  chmod + r ubuntu_20_04.tar<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="bash">docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来 迁移到其他地方<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><br>- 关于容器(<span class="hljs-keyword">container</span>)的命令//中括号里面的是可以省略的意思<br><br>```bash<br>docker <span class="hljs-comment">[container]</span> create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。<br>docker ps -a：查看本地的所有容器<br>docker <span class="hljs-comment">[container]</span> start <span class="hljs-keyword">CONTAINER</span>：启动容器<br>docker <span class="hljs-comment">[container]</span> stop <span class="hljs-keyword">CONTAINER</span>：停止容器<br>docker <span class="hljs-comment">[container]</span> restart <span class="hljs-keyword">CONTAINER</span>：重启容器<br>docker <span class="hljs-comment">[contaienr]</span> run -itd ubuntu:20.04：创建并启动一个容器<br>docker <span class="hljs-comment">[container]</span> attach <span class="hljs-keyword">CONTAINER</span>：进入容器<br>先按Ctrl-p，再按Ctrl-q可以挂起容器<br>docker <span class="hljs-comment">[container]</span> exec <span class="hljs-keyword">CONTAINER</span> COMMAND：在容器中执行命令<br>docker <span class="hljs-comment">[container]</span> rm <span class="hljs-keyword">CONTAINER</span>：删除容器//删除容器之前得关掉容器<br>docker <span class="hljs-keyword">container</span> prune：删除所有已停止的容器<br>docker export -o xxx.tar <span class="hljs-keyword">CONTAINER</span>：将容器<span class="hljs-keyword">CONTAINER</span>导出到本地文件xxx.tar中<br>docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag<br>docker export/import与docker save/load的区别：<br>export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br>save/load会保存完整记录，体积更大<br>docker top <span class="hljs-keyword">CONTAINER</span>：查看某个容器内的所有进程<br>docker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息<br>docker cp xxx <span class="hljs-keyword">CONTAINER</span>:xxx 或 docker cp <span class="hljs-keyword">CONTAINER</span>:xxx xxx：在本地和容器间复制文件<br>docker rename CONTAINER1 CONTAINER2：重命名容器<br>docker update <span class="hljs-keyword">CONTAINER</span> --memory 500MB：修改容器限制<br></code></pre></td></tr></table></figure></code></pre></li><li><p>两个云服务器之间不能直接传docker</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/2022/07/31/My-New-Post/"/>
    <url>/2022/07/31/My-New-Post/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/31/My-New-Post/%E4%BD%9C%E4%B8%9A1.4.0.png" class>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode11</title>
    <link href="/2022/07/30/Leetcode11/"/>
    <url>/2022/07/30/Leetcode11/</url>
    
    <content type="html"><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>双指针算法，用两个指针 i,j分别指向首尾，如果 ai&gt;aj，则 j−−；否则 i++，直到 i&#x3D;j为止，每次迭代更新最大值。</p><img src="/2022/07/30/Leetcode11/image-20220305105220834.png" class><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; )<span class="hljs-comment">//注意最后的分号，这是跳出循环的关键</span><br>        &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>            <span class="hljs-keyword">if</span> (height[i] &gt; height[j]) j -- ;<br>            <span class="hljs-keyword">else</span> i ++ ;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/30/hello-world/"/>
    <url>/2022/07/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
